<!DOCTYPE html>

<html>
    <head>
        <link rel = "stylesheet" href = "../styles/all.css">

        <Title>
            Poredjenje
        </Title>

        <style>
            #viewport-containerF {
                position: absolute; top: 25px; left: 50%;
                transform: translateX(-50%);
                width: 45vw; height: 45vh; min-height: 45vh;
                z-index: 10;
                display: block;
            }

            #viewport-containerS {
                position: absolute; top: 25px; left: 50%;
                transform: translateX(-50%);
                width: 45vw; height: 45vh; min-height: 45vh;
                z-index: 10;
                display: block
            }

            #leftGPU {
                position: fixed;
                width: 50%;
                height: 100%;
                top: 0;
                left: 0;
            }

            #rightGPU {
                position: fixed;
                width: 50%;
                height: 100%;
                top: 0;
                right: 0;
            }

            .specContainer {
                position: absolute;
                left: 50%;
                top: 35vh;
                height: auto;
                width: 45vw;
                transform: translateX(-50%);
                background: transparent;
                padding: 20px;
                border-radius: 10px;
                color: white;
                font-family: 'Courier New', monospace;
                z-index: 20;
                outline: 2px solid white;
                overflow: hidden;
            }

            .specGrid {
                display: grid;
                grid-template-columns: 1fr 2fr;
                gap: 10px;
                width: 100%;
                min-height: 5vh;
                height: auto;
                outline: 1px solid white;
            }

            .specName {
                font-weight: bold;
                text-align: center;
                grid-column: 1;
                height: 100%;
                color: white;
                overflow-wrap: break-word;
                font-size: 3vh;
            }

            .specDescription {
                grid-column: 2;
                height: 100%;
                color: white;
                overflow-wrap: break-word;
                text-align: center;
                font-size: 3vh;
            }

            .specName::after {
                color: white;
                content: ":";
            }

            .finePrint {
                position: fixed;
                bottom: 10px;
                left: 0px;
                width: 100%;
                text-align: center;
                font-family: 'Courier New', monospace;
                color: white;
                filter: grayscale(30%) brightness(75%);
                font-size: 2vh;
                z-index: 10;
            }
        </style>
    </head>

    <body>
        <div id = "leftGPU" class = "cosmic-blue-background">
            <div id="viewport-containerF">
            </div>
        </div>

        <div id = "rightGPU" class = "cosmic-red-background">
            <div id="viewport-containerS">

            </div>
        </div>

        <div class = "cosmic-rain-background"></div>

        <div id = "susCover"></div>

        <div class="finePrint">
            Кликни да покренеш страницу
        </div>

        <nav class="slide-nav-container">
            <div class="slide-nav-scroll">
                <button class="nav-btn" onclick="window.location.href='../index.html'">GPU</button>
                <button class="nav-btn" onclick="window.location.href='Istorijat.html'">Istorijat</button>
                <button class="nav-btn active" onclick="window.location.href='Poredjenje.html'">Poredjenje</button>
                <button class="nav-btn" onclick="window.location.href='Konstrukcija.html'">Konstrukcija</button>
                <button class="nav-btn" onclick="window.location.href='Upotreba.html'">Upotreba</button>
                <button class="nav-btn" onclick="window.location.href='Zakljucak.html'">Zakljucak</button>
            </div>
        </nav>

        <iframe id = "loadingScreen" src = "https://masterclassonrighttrack.github.io/GPU_Project/GPU_Gen_loading_screen/GPU_Gen.html">

        </iframe>
    </body>

    <script id = "metadata">
        window.RTX3080_CameraLocation = {
            x: -2.244198972735674,
            y:  4.980783784515609,
            z:  5.504571852258874
        }
    </script>

    <script type = "module" id = "design">
        import {xDetail, dotDetail, textSection, smartUI} from "../modules/details.js";
        import {textLoader, jsonLoader} from "../modules/dataLoader.js";

        async function StartLoading() {
            // main component for xDetail are (number of x's, position, [shouldAnimate, shouldSwipe, swipeDirection])
            window.oxDetail = await xDetail(6, "_globalTopLeft", [true, true, "left"]);
            // main component for dotDetail are (number of x's, position, [shouldAnimate, shouldSwipe, swipeDirection])
            window.odotDetail = await dotDetail(3, "_globalBottomRight", [true, true, "right"]);
            
            window.addEventListener("keydown", (event) => {
                if (event.shiftKey && event.key.toUpperCase() === "P") {
                    oxDetail.unload();
                    odotDetail.unload();
                    // textContainer.unload();
                }
            });
        }

        window.action = {
            contentLoaded: false,
        };

        window.actionProxy = new Proxy(action, {
            set(table, property, value) {
                if (property == "contentLoaded" && value) {
                    table[property] = value;
                    StartLoading();
                    return true;
                }
            }
        })
    </script>

    <script id = "script_loadingScreen">
            let i_horizontal = window.innerWidth / 50;
            let i_vertical = window.innerHeight / 50;

            let rectCounter = 0;

            for (let y = 0; y < i_vertical; y++) {
                for (let x = 0; x < i_horizontal; x++) {
                    rectCounter += 1;
                }
            }

            const unloadTime = rectCounter * 0.01 + 2 + 0.5; // 1 is message sending delay time


            window.wait = (seconds) => new Promise(resolve => {setTimeout(resolve, seconds * 1000)})
            const loadingFrame = document.getElementById("loadingScreen");
            const susCover = document.getElementById("susCover");

            let precentage = 0;

            async function loadLoadingBar() {
                loadingFrame.author = "Zimin (II7) 2026"
                for (let i = 0; i < 10; i++) {
                    loadingFrame.contentWindow.postMessage({
                        type: 'SET_BAR',
                        value: precentage
                    }, 'https://masterclassonrighttrack.github.io'); // Security: Only send to this URL
                    precentage += 10;
                    await wait(1);
                };

                loadingFrame.contentWindow.postMessage({
                    type: 'Unload',
                    value: 0
                }, 'https://masterclassonrighttrack.github.io'); // Security: Only send to this URL
                
                document.body.classList.remove("loadingBody");
                await wait(unloadTime)
                window.actionProxy.contentLoaded = true

                setTimeout(() => {
                    document.body.removeChild(loadingFrame);
                }, 2000)
            };

            loadingFrame.onload = function() {
                document.body.removeChild(susCover);
                loadLoadingBar();
            }

            const scrollContainer = document.querySelector(".slide-nav-scroll");

                scrollContainer.addEventListener("wheel", (event) => {
                    // Prevent the default vertical scroll
                    event.preventDefault();

                    scrollContainer.scrollLeft += event.deltaY;
                }, { passive: false });

                window.addEventListener("mousemove", (event) => {

                    const mouseY = event.clientY;
                    const windowHeight = window.innerHeight;

                    if (windowHeight - mouseY < (windowHeight * 0.2)) {
                        document.querySelector(".slide-nav-container").style.bottom = "20px";
                    } else {
                        document.querySelector(".slide-nav-container").style.bottom = "-10vh";
                    }
        });
    </script>

       <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { MeshLoader } from '../modules/meshLoader.js';

        const containerMeshPosition = {
            "viewport-containerS": {x: 5.633834299518307, y: 2.937159817294579, z: 2.507786425229848},
            "viewport-containerF": {x: -2.027814863134191, y: 1.8206564476884786, z: 5.045395532947526},
        }

        const COMPONENT_DATA = {}

        let partsMoved = false;

        let defaultParentPartsPosition = {
            "Mainboard": { x: -0.8473208546638489, y: 0.5898587107658386, z: 0.6116207242012024 },
            "UpperChassis": {x: 0.22403252124786377, y: 1.4063705205917358, z: -0.18959811329841614},
        }

        const gpuSpecifications = {
            "AMD FirePro W2100": {
                "TDP": "26W",
                "Memory Speed": "1.8 Gbps",
                "VRAM": "2 GB",
                "Vram Type": "DDR3",
                "Clock Speed": "630 MHz",
                "Realise Year": "2015",
            },
            "RTX 5090 Founders Edition": {
                "TDP": "575W",
                "Memory Speed": "28 Gbps",
                "VRAM": "32 GB",
                "Vram Type": "GDDR7",
                "Clock Speed": "2.02 GHz",
                "Realise Year": "2025",
            }
        };

        class App {
            constructor(containerId, modelUrl, clickFilter = []) {
                this.container = document.getElementById(containerId);
                this.clickFilter = clickFilter;
                
                this.defaultCamPos = containerMeshPosition[containerId];
                this.defaultZoom = 45;

                this.initEngine();
                this.initLights();

                console.log(containerId, this.container.clientHeight, this.container.clientWidth)
                
                this.loader = new MeshLoader(this.scene);
                this.loader.loadFromURL(modelUrl);

                window.addEventListener('resize', () => this.onWindowResize());

                this.animate();
            }

            initEngine() {
                this.scene = new THREE.Scene();
                
                this.camera = new THREE.PerspectiveCamera(this.defaultZoom, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
                this.camera.position.set(this.defaultCamPos.x, this.defaultCamPos.y, this.defaultCamPos.z);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.container.appendChild(this.renderer.domElement);

                this.labelRenderer = new CSS2DRenderer();
                this.labelRenderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.labelRenderer.domElement.style.position = 'absolute';
                this.labelRenderer.domElement.style.top = '0px';
                this.labelRenderer.domElement.style.pointerEvents = 'none';
                this.container.appendChild(this.labelRenderer.domElement);
            }


            setCamera(pos = this.defaultCamPos, zoom = this.defaultZoom, duration = 1.2) {
                gsap.to(this.camera.position, {
                    x: pos.x,
                    y: pos.y,
                    z: pos.z,
                    duration: duration,
                    ease: "power2.inOut",
                    onUpdate: () => this.camera.lookAt(0, 0, 0)
                });

                gsap.to(this.camera, {
                    fov: zoom,
                    duration: duration,
                    ease: "power2.inOut",
                    onUpdate: () => this.camera.updateProjectionMatrix()
                });


            }

            onWindowResize() {
                // 1. Update the camera's aspect ratio
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                
                // 2. Recalculate the projection matrix
                this.camera.updateProjectionMatrix();

                // 3. Update the size of both renderers
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.labelRenderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }


            initLights() {
                const ambient = new THREE.AmbientLight(0xffffff, 1.2); 
                const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
                mainLight.position.set(5, 10, 7.5);
                const rimLight = new THREE.PointLight(0x00f2ea, 15, 50);
                rimLight.position.set(-5, 5, 0);
                this.scene.add(ambient, mainLight, rimLight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                if (this.loader) this.loader.update(0.016);
                this.renderer.render(this.scene, this.camera);
                this.labelRenderer.render(this.scene, this.camera);
            }
        }

        
        const myApp = new App('viewport-containerF', 'https://raw.githubusercontent.com/MasterClassOnRightTrack/GPU_Project/main/mesh/RTX5090.glb', Object.keys(COMPONENT_DATA));

        const myApp2 = new App('viewport-containerS', 'https://raw.githubusercontent.com/MasterClassOnRightTrack/GPU_Project/main/mesh/amd_fire_pro_w2100.glb', Object.keys(COMPONENT_DATA));
        const partContainer = document.querySelector(".part-nav-scroll");




        const svgNS = "http://www.w3.org/2000/svg"; // The magic "Namespace" URL

        for (const [key, value] of Object.entries(gpuSpecifications)) {
            const parent = (key === "AMD FirePro W2100") ? document.getElementById("viewport-containerS") : document.getElementById("viewport-containerF");
            const GeneratingSpeed = parent.id === "viewport-containerS" ? 0.1 : 0.0011; // Simulate different loading speeds for the two GPUs

            const specContainer = document.createElement("div");
            specContainer.classList.add("specContainer");

            const title = document.createElement("h2");
            title.textContent = key;
            title.style.textAlign = "center";
            title.style.gridColumn = "1 / span 2";
            specContainer.appendChild(title);

            const canvas = document.createElementNS(svgNS, "svg");
            canvas.setAttribute("width", "100%");
            canvas.setAttribute("height", "100%");
            canvas.style.position = "absolute";
            canvas.style.top = "0";
            canvas.style.left = "0";

            specContainer.appendChild(canvas);

            function regenerate() {
                let i_horizontal = parent.offsetWidth / 50;
                let i_vertical = parent.offsetHeight / 50;

                for (let y = 0; y < i_vertical; y++) {
                    for (let x = 0; x < i_horizontal; x++) {
                        let posX = x * 50;
                        let posY = y * 50;

                        // 1. Create the element with the Namespace
                        const rect = document.createElementNS(svgNS, "rect");

                        // 2. Use setAttribute for EVERYTHING
                        rect.setAttribute("x", posX);
                        rect.setAttribute("y", posY);
                        rect.setAttribute("width", 50);
                        rect.setAttribute("height", 50);

                        rect.setAttribute("fill", "black");
                        
                        // Optional: Add a border so you can see the grid
                        rect.setAttribute("stroke", "white");
                        rect.setAttribute("stroke-width", "1");

                        canvas.appendChild(rect);
                    }
                }
            }

            regenerate()

            const wait = (seconds) => new Promise(resolve => {setTimeout(resolve, seconds * 1000)});

            let shouldResize = true;

            for (const [specName, specDescription] of Object.entries(value)) {
                const nameElement = document.createElement("div");
                nameElement.classList.add("specName");
                nameElement.textContent = specName;
                specContainer.appendChild(nameElement);

                const descriptionElement = document.createElement("div");
                descriptionElement.classList.add("specDescription");
                descriptionElement.textContent = specDescription;
                specContainer.appendChild(descriptionElement);

            }

            window.addEventListener("resize", () => {
                if (shouldResize) {
                    canvas.innerHTML = "";
                    regenerate();
                }
            });

            let clickDebounce = false;

            let list = [];

            for (let i = 0; i < canvas.children.length; i++) {
                const rect = canvas.children[i];
                list.push(rect);
            }

            window.addEventListener("click", () => {
                shouldResize = false;

                if (clickDebounce) return;
                if (!actionProxy.contentLoaded) return;
                clickDebounce = true;

                async function generate(params) {
                    // Start at the last index and go to 0
                    for (let i = list.length - 1; i >= 0; i--) {
                        const rect = list[i];
                        await wait(GeneratingSpeed);
                        canvas.removeChild(rect);
                    };
                };

                generate();

            });

            parent.appendChild(specContainer);
        }

        window.addEventListener("click", () => {
            document.querySelector(".finePrint").style.display = "none";
        });
    </script>
</html>